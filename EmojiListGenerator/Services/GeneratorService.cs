using System.Globalization;
using Microsoft.Extensions.Configuration;

namespace EmojiListGenerator.Services {
    internal class GeneratorService : IGeneratorService {
        #region Fields

        private readonly IConfiguration _config;

        #endregion
        #region Constants

        private const string OutFile = "./../Emoji.cs";

        internal static readonly char[] Separator = [' ', '-', ',', '’', '!', '“', '”', '(', ')', '.'];

        #endregion
        #region Properties

        public string SourceUrl { get; set; } = "https://unicode.org/Public/emoji/15.1/emoji-test.txt";

        public float MaxVersion { get; set; } = 15.1F;

        #endregion
        #region Constructors

        public GeneratorService(IConfiguration config) {
            _config = config;
        }

        #endregion
        #region Method - FormatName

        private static string FormatName(string source) {
            var parts = source
                .Replace(':', '_')
                .Replace('-', ' ')
                .Replace("&", "And")
                .Replace("#", "NumberSign")
                .Replace("*", "Asterisk")
                .Replace(",", string.Empty)
                .Replace("’", string.Empty)
                .Split(Separator, StringSplitOptions.RemoveEmptyEntries)
                .Select(x => CultureInfo.InvariantCulture.TextInfo.ToTitleCase(x));

            return string.Concat(parts);
        }

        #endregion
        #region Method - RunAsync

        public async Task RunAsync() {
            // Initialise from config
            string? tempSourceUrl = _config.GetValue<string>("EmojiSourceUrl");
            if (!string.IsNullOrWhiteSpace(tempSourceUrl)) {
                SourceUrl = tempSourceUrl;
            }
            float? tempMaxVersion = _config.GetValue<float>("MaxVersion");
            if (tempMaxVersion != null) {
                MaxVersion = tempMaxVersion.Value;
            }

            Console.WriteLine($"Source:{SourceUrl} Destination:{OutFile}");

            using var destination = File.CreateText(OutFile);

            using var source = await DownloadAsync().ConfigureAwait(false);

            await destination.WriteLineAsync("// <auto-generated />");
            await destination.WriteLineAsync("namespace System.Text");
            await destination.WriteLineAsync("{");

            await destination.WriteLineAsync("    /// <summary>");
            await destination.WriteLineAsync($"    /// Full Emoji list (as unicode version {MaxVersion:0.0}), generated {DateTimeOffset.UtcNow:R}.");
            await destination.WriteLineAsync("    /// </summary>");
            await destination.WriteLineAsync("    /// <remarks>");
            await destination.WriteLineAsync($"    /// Created from {SourceUrl} using https://github.com/justdmitry/FullEmojiList generator.");
            await destination.WriteLineAsync("    /// </remarks>");
            await destination.WriteLineAsync("    public static class Emoji");
            await destination.WriteLineAsync("    {");

            var groupCount = 0;
            var emojiCount = 0;

            var lastGroup = string.Empty;
            var lastSubgroup = string.Empty;

            await foreach (var (group, subgroup, name, value) in ParseSourceAsync(source)) {
                if (group != lastGroup) {
                    if (groupCount > 0) {
                        await destination.WriteLineAsync($"        #endregion");
                        await destination.WriteLineAsync();
                    }

                    lastGroup = group;
                    groupCount++;
                    await destination.WriteLineAsync($"        #region {group}");
                }

                await destination.WriteLineAsync($"        public const string {name} = \"{value}\";");

                emojiCount++;
            }

            if (groupCount > 0) {
                await destination.WriteLineAsync($"        #endregion");
            }

            await destination.WriteLineAsync("    }");
            await destination.WriteLineAsync("}");
            await destination.FlushAsync();

            Console.WriteLine();
            Console.WriteLine("DONE");
            Console.WriteLine($"  Groups: {groupCount}");
            Console.WriteLine($"  Emojis: {emojiCount}");
        }

        #endregion
        #region Method - DownloadAsync

        private async Task<StreamReader> DownloadAsync() {
            var httpClient = new HttpClient();
            var response = await httpClient.GetAsync(SourceUrl).ConfigureAwait(false);
            response.EnsureSuccessStatusCode();
            var stream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false);
            return new StreamReader(stream);
        }

        #endregion
        #region Method - ParseSourceAsync

        private async IAsyncEnumerable<(string group, string subgroup, string name, string value)> ParseSourceAsync(StreamReader stream) {
            const string GroupPrefix = "# group:";
            const string SubgroupPrefix = "# subgroup:";
            const string CommentPrefix = "#";

            var group = string.Empty;
            var subgroup = string.Empty;

            while (!stream.EndOfStream) {
                var line = await stream.ReadLineAsync();

                if (string.IsNullOrWhiteSpace(line)) {
                    continue;
                }

                if (line.StartsWith(GroupPrefix, StringComparison.Ordinal)) {
                    group = FormatName(line[GroupPrefix.Length..]);
                    continue;
                }

                if (line.StartsWith(SubgroupPrefix, StringComparison.Ordinal)) {
                    subgroup = FormatName(line[SubgroupPrefix.Length..]);
                    continue;
                }

                if (line.StartsWith(CommentPrefix, StringComparison.Ordinal)) {
                    continue;
                }

                var emoji = ParseEmoji(line);
                if (emoji != null) {
                    yield return (group, subgroup, emoji.Value.name, emoji.Value.value);
                }
            }
        }

        #endregion
        #region Method - ParseEmoji

        private (string name, string value)? ParseEmoji(string line) {
            var parts = line.Split([';', '#'], 3);

            if (parts[1].Trim() != "fully-qualified") {
                return null;
            }

            var versionAndName = parts[2].Split('E', 2)[1].Split(' ', 2);
            var version = float.Parse(versionAndName[0]);

            if (version > MaxVersion) {
                return null;
            }

            var name = FormatName(versionAndName[1]);

            if (char.IsDigit(name[0])) {
                name = "_" + name;
            }

            var surrogates = parts[0].Trim()
                .Split(' ', StringSplitOptions.RemoveEmptyEntries)
                .Select(x => int.Parse(x, NumberStyles.HexNumber))
                .Select(x => char.ConvertFromUtf32(x));

            var value = string.Concat(surrogates);

            return (name, value);
        }

        #endregion
    }
}
